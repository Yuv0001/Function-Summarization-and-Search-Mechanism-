{
    "pdf2string": {
        "name": "pdf2string",
        "docstring": "No docstring provided",
        "called_functions": [
            "open",
            "extract_text"
        ],
        "code": "def pdf2string(pdf_path: str) -> str:\n    with open(pdf_path, 'rb') as file:\n        text = extract_text(file)\n    text = re.sub('\\\\s[,.]', ',', text)\n    text = re.sub('[\\n]+', '\\n', text)\n    text = re.sub('[\\\\s]+', ' ', text)\n    text = re.sub('http[s]?(://)?', '', text)\n    return text",
        "summary": "Code: def pdf2string(pdf_path: str) -> str:   with open( PDF_path, 'rb') as file: text = extract_text(file) text = re.sub('http[s]?(://)?', '', text) return text. Docstring: No docstring provided.",
        "ast": "FunctionDef(name='pdf2string', args=arguments(posonlyargs=[], args=[arg(arg='pdf_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='pdf_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='extract_text', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\\\s[,.]'), Constant(value=','), Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[\\n]+'), Constant(value='\\n'), Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[\\\\s]+'), Constant(value=' '), Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='http[s]?(://)?'), Constant(value=''), Name(id='text', ctx=Load())], keywords=[])), Return(value=Name(id='text', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load()))"
    },
    "parse_jd": {
        "name": "parse_jd",
        "docstring": "No docstring provided",
        "called_functions": [
            "pdf2string"
        ],
        "code": "def parse_jd(pdf_path: str) -> dict:\n    resume = {}\n    pdf_str = pdf2string(pdf_path)\n    prompt = PROMPT_QUESTIONS_JD + '\\n' + pdf_str\n    engine = 'gpt-3.5-turbo-1106'\n    response = openai.ChatCompletion.create(model=engine, messages=[{'role': 'system', 'content': PROMPT_QUESTIONS_JD}, {'role': 'user', 'content': pdf_str}])\n    response_text = response['choices'][0]['message']['content'].strip()\n    resume = response_text\n    return resume",
        "summary": "The function parse_jd is called with a docstring. No docstring is provided. The function takes a dict and returns a string. The dict is the body of the string.",
        "ast": "FunctionDef(name='parse_jd', args=arguments(posonlyargs=[], args=[arg(arg='pdf_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='resume', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='pdf_str', ctx=Store())], value=Call(func=Name(id='pdf2string', ctx=Load()), args=[Name(id='pdf_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prompt', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='PROMPT_QUESTIONS_JD', ctx=Load()), op=Add(), right=Constant(value='\\n')), op=Add(), right=Name(id='pdf_str', ctx=Load()))), Assign(targets=[Name(id='engine', ctx=Store())], value=Constant(value='gpt-3.5-turbo-1106')), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='engine', ctx=Load())), keyword(arg='messages', value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Name(id='PROMPT_QUESTIONS_JD', ctx=Load())]), Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='pdf_str', ctx=Load())])], ctx=Load()))])), Assign(targets=[Name(id='response_text', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='resume', ctx=Store())], value=Name(id='response_text', ctx=Load())), Return(value=Name(id='resume', ctx=Load()))], decorator_list=[], returns=Name(id='dict', ctx=Load()))"
    },
    "remove_backticks_and_json": {
        "name": "remove_backticks_and_json",
        "docstring": "No docstring provided",
        "called_functions": [
            "len",
            "len",
            "len"
        ],
        "code": "def remove_backticks_and_json(text):\n    if text.startswith('```'):\n        text = text[len('```'):]\n        if text.startswith('json'):\n            text = text[len('json'):]\n    if text.endswith('```'):\n        text = text[:-len('```')]\n    text = text.strip()\n    return text",
        "summary": "Function name: remove_backticks_and_json. Docstring: No docstring provided. Code: def remove_backseticksandjson(text): text = text.strip() return text...",
        "ast": "FunctionDef(name='remove_backticks_and_json', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='```')], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='```')], keywords=[])), ctx=Load())), If(test=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='json')], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='json')], keywords=[])), ctx=Load()))], orelse=[])], orelse=[]), If(test=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='```')], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='```')], keywords=[]))), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='text', ctx=Load()))], decorator_list=[])"
    },
    "process_jd": {
        "name": "process_jd",
        "docstring": "No docstring provided",
        "called_functions": [
            "parse_jd",
            "str"
        ],
        "code": "def process_jd(folder_path: str):\n    try:\n        parsed_jd = parse_jd(folder_path)\n        return parsed_jd\n    except Exception as e:\n        return f'Error processing the JD: {str(e)}'",
        "summary": "Code: def process_jd( folder_path: str): return f'Error processing the JD: {str(e)}'...",
        "ast": "FunctionDef(name='process_jd', args=arguments(posonlyargs=[], args=[arg(arg='folder_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='parsed_jd', ctx=Store())], value=Call(func=Name(id='parse_jd', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), Return(value=Name(id='parsed_jd', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=JoinedStr(values=[Constant(value='Error processing the JD: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)]))])], orelse=[], finalbody=[])], decorator_list=[])"
    },
    "parse_resume": {
        "name": "parse_resume",
        "docstring": "No docstring provided",
        "called_functions": [
            "pdf2string"
        ],
        "code": "def parse_resume(pdf_path: str) -> dict:\n    resume = {}\n    pdf_str = pdf2string(pdf_path)\n    prompt = PROMPT_QUESTIONS_RESUME + '\\n' + pdf_str\n    engine = 'gpt-3.5-turbo-1106'\n    response = openai.ChatCompletion.create(model=engine, messages=[{'role': 'system', 'content': PROMPT_QUESTIONS_RESUME}, {'role': 'user', 'content': pdf_str}])\n    response_text = response['choices'][0]['message']['content'].strip()\n    resume = response_text\n    return resume",
        "summary": "Parsing a resume requires the use of a docstring. No docstring was provided for this function. The function parse_resume is called with a dict. The dict is the body of the resume.",
        "ast": "FunctionDef(name='parse_resume', args=arguments(posonlyargs=[], args=[arg(arg='pdf_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='resume', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='pdf_str', ctx=Store())], value=Call(func=Name(id='pdf2string', ctx=Load()), args=[Name(id='pdf_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prompt', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='PROMPT_QUESTIONS_RESUME', ctx=Load()), op=Add(), right=Constant(value='\\n')), op=Add(), right=Name(id='pdf_str', ctx=Load()))), Assign(targets=[Name(id='engine', ctx=Store())], value=Constant(value='gpt-3.5-turbo-1106')), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='engine', ctx=Load())), keyword(arg='messages', value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Name(id='PROMPT_QUESTIONS_RESUME', ctx=Load())]), Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='pdf_str', ctx=Load())])], ctx=Load()))])), Assign(targets=[Name(id='response_text', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='resume', ctx=Store())], value=Name(id='response_text', ctx=Load())), Return(value=Name(id='resume', ctx=Load()))], decorator_list=[], returns=Name(id='dict', ctx=Load()))"
    },
    "process_resume": {
        "name": "process_resume",
        "docstring": "No docstring provided",
        "called_functions": [
            "parse_resume",
            "str"
        ],
        "code": "def process_resume(file_path: str):\n    try:\n        parsed_resume = parse_resume(file_path)\n        return parsed_resume\n    except Exception as e:\n        return f'Error processing the resume: {str(e)}'",
        "summary": "Code: def process_resume(file_path: str): return f'Error processing the resume: {str(e)}'.... Docstring: No docstring provided.",
        "ast": "FunctionDef(name='process_resume', args=arguments(posonlyargs=[], args=[arg(arg='file_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='parsed_resume', ctx=Store())], value=Call(func=Name(id='parse_resume', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Return(value=Name(id='parsed_resume', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=JoinedStr(values=[Constant(value='Error processing the resume: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)]))])], orelse=[], finalbody=[])], decorator_list=[])"
    },
    "document_load": {
        "name": "document_load",
        "docstring": "No docstring provided",
        "called_functions": [
            "PyMuPDFLoader",
            "enumerate"
        ],
        "code": "def document_load(file_path: str):\n    loader = PyMuPDFLoader(file_path)\n    pages = loader.load()\n    resume_dict = {}\n    for (i, document) in enumerate(pages, start=1):\n        page_key = f'Page_{i}'\n        resume_dict[page_key] = document.page_content\n    resume_json = json.dumps(resume_dict, indent=2)\n    return resume_json",
        "summary": "The function document_load is used to load a document. The function uses the PyMuPDFLoader to load the document. No docstring is provided for this function.",
        "ast": "FunctionDef(name='document_load', args=arguments(posonlyargs=[], args=[arg(arg='file_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='loader', ctx=Store())], value=Call(func=Name(id='PyMuPDFLoader', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pages', ctx=Store())], value=Call(func=Attribute(value=Name(id='loader', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='resume_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='document', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='pages', ctx=Load())], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[Assign(targets=[Name(id='page_key', ctx=Store())], value=JoinedStr(values=[Constant(value='Page_'), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1)])), Assign(targets=[Subscript(value=Name(id='resume_dict', ctx=Load()), slice=Name(id='page_key', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='document', ctx=Load()), attr='page_content', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='resume_json', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dumps', ctx=Load()), args=[Name(id='resume_dict', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=2))])), Return(value=Name(id='resume_json', ctx=Load()))], decorator_list=[])"
    },
    "summarize": {
        "name": "summarize",
        "docstring": "No docstring provided",
        "called_functions": [],
        "code": "def summarize(pdf_content, prompt):\n    model = genai.GenerativeModel('gemini-pro')\n    response = model.generate_content([pdf_content, prompt])\n    return response.text",
        "summary": "Code: def summarize(pdf_content, prompt): model = genai.GenerativeModel('gemini-pro') response = model.generate_content([pdf_ content, prompt]) return response.text...",
        "ast": "FunctionDef(name='summarize', args=arguments(posonlyargs=[], args=[arg(arg='pdf_content'), arg(arg='prompt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='model', ctx=Store())], value=Call(func=Attribute(value=Name(id='genai', ctx=Load()), attr='GenerativeModel', ctx=Load()), args=[Constant(value='gemini-pro')], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='model', ctx=Load()), attr='generate_content', ctx=Load()), args=[List(elts=[Name(id='pdf_content', ctx=Load()), Name(id='prompt', ctx=Load())], ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='response', ctx=Load()), attr='text', ctx=Load()))], decorator_list=[])"
    },
    "summarize_resume": {
        "name": "summarize_resume",
        "docstring": "No docstring provided",
        "called_functions": [
            "document_load",
            "summarize",
            "str"
        ],
        "code": "def summarize_resume(file_path: str):\n    try:\n        parsed_resume = document_load(file_path)\n        summurized_resume = summarize(parsed_resume, SUMMARIZE_RESUME_PROMPT)\n        return summurized_resume\n    except Exception as e:\n        return f'Error processing the resume summary: {str(e)}'",
        "summary": "Code: def summarize_resume(file_path: str): return f'Error processing the resume summary: {str(e)}'...",
        "ast": "FunctionDef(name='summarize_resume', args=arguments(posonlyargs=[], args=[arg(arg='file_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='parsed_resume', ctx=Store())], value=Call(func=Name(id='document_load', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='summurized_resume', ctx=Store())], value=Call(func=Name(id='summarize', ctx=Load()), args=[Name(id='parsed_resume', ctx=Load()), Name(id='SUMMARIZE_RESUME_PROMPT', ctx=Load())], keywords=[])), Return(value=Name(id='summurized_resume', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=JoinedStr(values=[Constant(value='Error processing the resume summary: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)]))])], orelse=[], finalbody=[])], decorator_list=[])"
    },
    "summarize_jd": {
        "name": "summarize_jd",
        "docstring": "No docstring provided",
        "called_functions": [
            "document_load",
            "summarize",
            "str"
        ],
        "code": "def summarize_jd(file_path: str):\n    try:\n        parsed_jd = document_load(file_path)\n        summarized_jd = summarize(parsed_jd, SUMMARIZE_JD_PROMPT)\n        return summarized_jd\n    except Exception as e:\n        return f'Error processing the resume : {str(e)}'",
        "summary": "Code: def summarize_jd(file_path: str): try: parsed_Jd = document_load( file_path) return summarized_jD. except Exception as e: return f'Error processing the resume : {str(e)}'...",
        "ast": "FunctionDef(name='summarize_jd', args=arguments(posonlyargs=[], args=[arg(arg='file_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='parsed_jd', ctx=Store())], value=Call(func=Name(id='document_load', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='summarized_jd', ctx=Store())], value=Call(func=Name(id='summarize', ctx=Load()), args=[Name(id='parsed_jd', ctx=Load()), Name(id='SUMMARIZE_JD_PROMPT', ctx=Load())], keywords=[])), Return(value=Name(id='summarized_jd', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=JoinedStr(values=[Constant(value='Error processing the resume : '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)]))])], orelse=[], finalbody=[])], decorator_list=[])"
    },
    "match_profile": {
        "name": "match_profile",
        "docstring": "No docstring provided",
        "called_functions": [
            "OpenAI",
            "PromptTemplate",
            "LLMChain"
        ],
        "code": "def match_profile(jd_json, res_json):\n    template = 'You are a skilled ATS (Applicant Tracking System) scanner with a deep understanding of {stack}, \\n    your task is to evaluate the resume against the provided job description. Match the required Expereince, Technical Skills and Soft Skills of JD with\\n    candidate\\'s Expereince, Technical Skills and Soft Skills. Give matching percentge of Experience,Technical skills and Soft Skills  candidate resume with JD.\\n    Also consider the candidate experience and experience required.\\n\\n    **Important:** \\n    - If a candidate has more experience than required, consider it as a full match for experience.\\n    - Only consider skills that are explicitly mentioned in the job description for skills matching. Exclude any candidate skills that are not listed in the JD.\\n    - If candidate experience is less than required experience, decrease the match percent of technical skills by 10 and soft skill by 5 as with low experience, lower the technical and soft skill will be\\n\\n    Job Description:\\n    {job_description} of experience in {stack}\\n    \\n\\n    Experienced Required:\\n    {expereinced_required} of experience in {stack}\\n    \\n\\n    Required Technical Skills:\\n    {required_tech_skills}\\n    \\n\\n    Required Soft Skills:\\n    {required_soft_skills}\\n    \\n\\n    \\n    Below is the infomration about candidate resume.\\n    Candidate Name:\\n    {candidate_name}\\n    \\n\\n    Candidate Relavant Expereince:\\n    {candidate_experience}\\n    \\n\\n    Technical Skills:\\n    {candidate_tech_skills}\\n    \\n\\n    Soft Skills:\\n    {candidate_soft_skills}\\n    \\n\\n\\n    Based on the given input, give reason for the provided match percentage.\\n    Give output in json format with Candidate Name,Experience,Technical skills with number of technical skill matched and Soft Skills, do not mention the aggregate percentage in reason:\\n    {{\\n        \"Candidate Name\": \"\",\\n        \"Experience\": {{\\n            \"Candidate Experience\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Technical Skills\": {{\\n            \"Number of Technical Skills Matched / JD Technical Skills\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Soft Skills\": {{\\n            \"Number of Technical Skills Matched / JD Soft Skills\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Reason\": \"\"\\n    }}\\n    '\n    llm = OpenAI(model_name='gpt-3.5-turbo-instruct', temperature=0)\n    prompt_input = {'stack': jd_json['job_title'], 'job_description': jd_json['job_summary'], 'expereinced_required': jd_json['experience'], 'required_tech_skills': jd_json['skills']['Technical skills'], 'required_soft_skills': jd_json['skills']['Soft skills'], 'candidate_name': res_json['basic_info']['full_name'], 'candidate_experience': res_json['Total Work Experience'], 'candidate_tech_skills': res_json['skills']['Technical skills'], 'candidate_soft_skills': res_json['skills']['Soft skills']}\n    prompt = PromptTemplate(input_variables=['stack', 'job_description', 'expereinced_required', 'required_tech_skills', 'required_soft_skills', 'candidate_name', 'candidate_experience', 'candidate_tech_skills', 'candidate_soft_skills'], template=template)\n    chain = LLMChain(llm=llm, prompt=prompt)\n    output = chain.invoke(prompt_input)\n    return output['text']",
        "summary": "Match the required Expereince, Technical Skills and Soft Skills of JD with the candidate's resume. Give matching percentge of Experience, technical skills and Soft skills.",
        "ast": "FunctionDef(name='match_profile', args=arguments(posonlyargs=[], args=[arg(arg='jd_json'), arg(arg='res_json')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='template', ctx=Store())], value=Constant(value='You are a skilled ATS (Applicant Tracking System) scanner with a deep understanding of {stack}, \\n    your task is to evaluate the resume against the provided job description. Match the required Expereince, Technical Skills and Soft Skills of JD with\\n    candidate\\'s Expereince, Technical Skills and Soft Skills. Give matching percentge of Experience,Technical skills and Soft Skills  candidate resume with JD.\\n    Also consider the candidate experience and experience required.\\n\\n    **Important:** \\n    - If a candidate has more experience than required, consider it as a full match for experience.\\n    - Only consider skills that are explicitly mentioned in the job description for skills matching. Exclude any candidate skills that are not listed in the JD.\\n    - If candidate experience is less than required experience, decrease the match percent of technical skills by 10 and soft skill by 5 as with low experience, lower the technical and soft skill will be\\n\\n    Job Description:\\n    {job_description} of experience in {stack}\\n    \\n\\n    Experienced Required:\\n    {expereinced_required} of experience in {stack}\\n    \\n\\n    Required Technical Skills:\\n    {required_tech_skills}\\n    \\n\\n    Required Soft Skills:\\n    {required_soft_skills}\\n    \\n\\n    \\n    Below is the infomration about candidate resume.\\n    Candidate Name:\\n    {candidate_name}\\n    \\n\\n    Candidate Relavant Expereince:\\n    {candidate_experience}\\n    \\n\\n    Technical Skills:\\n    {candidate_tech_skills}\\n    \\n\\n    Soft Skills:\\n    {candidate_soft_skills}\\n    \\n\\n\\n    Based on the given input, give reason for the provided match percentage.\\n    Give output in json format with Candidate Name,Experience,Technical skills with number of technical skill matched and Soft Skills, do not mention the aggregate percentage in reason:\\n    {{\\n        \"Candidate Name\": \"\",\\n        \"Experience\": {{\\n            \"Candidate Experience\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Technical Skills\": {{\\n            \"Number of Technical Skills Matched / JD Technical Skills\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Soft Skills\": {{\\n            \"Number of Technical Skills Matched / JD Soft Skills\": \"\",\\n            \"Match Percentage\": \"\"\\n        }},\\n        \"Reason\": \"\"\\n    }}\\n    ')), Assign(targets=[Name(id='llm', ctx=Store())], value=Call(func=Name(id='OpenAI', ctx=Load()), args=[], keywords=[keyword(arg='model_name', value=Constant(value='gpt-3.5-turbo-instruct')), keyword(arg='temperature', value=Constant(value=0))])), Assign(targets=[Name(id='prompt_input', ctx=Store())], value=Dict(keys=[Constant(value='stack'), Constant(value='job_description'), Constant(value='expereinced_required'), Constant(value='required_tech_skills'), Constant(value='required_soft_skills'), Constant(value='candidate_name'), Constant(value='candidate_experience'), Constant(value='candidate_tech_skills'), Constant(value='candidate_soft_skills')], values=[Subscript(value=Name(id='jd_json', ctx=Load()), slice=Constant(value='job_title'), ctx=Load()), Subscript(value=Name(id='jd_json', ctx=Load()), slice=Constant(value='job_summary'), ctx=Load()), Subscript(value=Name(id='jd_json', ctx=Load()), slice=Constant(value='experience'), ctx=Load()), Subscript(value=Subscript(value=Name(id='jd_json', ctx=Load()), slice=Constant(value='skills'), ctx=Load()), slice=Constant(value='Technical skills'), ctx=Load()), Subscript(value=Subscript(value=Name(id='jd_json', ctx=Load()), slice=Constant(value='skills'), ctx=Load()), slice=Constant(value='Soft skills'), ctx=Load()), Subscript(value=Subscript(value=Name(id='res_json', ctx=Load()), slice=Constant(value='basic_info'), ctx=Load()), slice=Constant(value='full_name'), ctx=Load()), Subscript(value=Name(id='res_json', ctx=Load()), slice=Constant(value='Total Work Experience'), ctx=Load()), Subscript(value=Subscript(value=Name(id='res_json', ctx=Load()), slice=Constant(value='skills'), ctx=Load()), slice=Constant(value='Technical skills'), ctx=Load()), Subscript(value=Subscript(value=Name(id='res_json', ctx=Load()), slice=Constant(value='skills'), ctx=Load()), slice=Constant(value='Soft skills'), ctx=Load())])), Assign(targets=[Name(id='prompt', ctx=Store())], value=Call(func=Name(id='PromptTemplate', ctx=Load()), args=[], keywords=[keyword(arg='input_variables', value=List(elts=[Constant(value='stack'), Constant(value='job_description'), Constant(value='expereinced_required'), Constant(value='required_tech_skills'), Constant(value='required_soft_skills'), Constant(value='candidate_name'), Constant(value='candidate_experience'), Constant(value='candidate_tech_skills'), Constant(value='candidate_soft_skills')], ctx=Load())), keyword(arg='template', value=Name(id='template', ctx=Load()))])), Assign(targets=[Name(id='chain', ctx=Store())], value=Call(func=Name(id='LLMChain', ctx=Load()), args=[], keywords=[keyword(arg='llm', value=Name(id='llm', ctx=Load())), keyword(arg='prompt', value=Name(id='prompt', ctx=Load()))])), Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='invoke', ctx=Load()), args=[Name(id='prompt_input', ctx=Load())], keywords=[])), Return(value=Subscript(value=Name(id='output', ctx=Load()), slice=Constant(value='text'), ctx=Load()))], decorator_list=[])"
    },
    "match_reason": {
        "name": "match_reason",
        "docstring": "No docstring provided",
        "called_functions": [
            "OpenAI",
            "PromptTemplate",
            "LLMChain"
        ],
        "code": "def match_reason(jd_summary, summarized_resume, result, stack):\n    template = 'You are a skilled ATS (Applicant Tracking System) scanner with a deep understanding of {stack}, \\n    your task is to evaluate the resume against the provided job description. Match the provide JD summary, Resume Summary, the percentage match of Experience,Technical skills and Soft Skills of candidate with respective of JD.\\n    Find the aggregate percentage and reason behind the percentage based upon the data provided.\\n\\n    **Important:** \\n    - If a candidate has more experience than required, consider it as a full match for experience.\\n    \\n    Job Description Summary:\\n    {jd_summary}\\n    \\n\\n    Summarized Resume:\\n    {summarized_resume}\\n    \\n\\n    Result:\\n    {result}\\n    \\n\\n    \\n    Based upon the given data, give a reason for aggregate percentage only. Also mention what sort of profile candidate is more suitable for'\n    llm = OpenAI(model_name='gpt-3.5-turbo-instruct', temperature=0)\n    prompt_input = {'stack': stack, 'jd_summary': jd_summary, 'summarized_resume': summarized_resume, 'result': result}\n    prompt = PromptTemplate(input_variables=['stack', 'jd_summary', 'summarized_resume', 'result'], template=template)\n    chain = LLMChain(llm=llm, prompt=prompt)\n    output = chain.invoke(prompt_input)\n    return output['text']",
        "summary": " template = 'You are a skilled ATS (Applicant Tracking System) scanner with a deep understanding of {stack}. Your task is to evaluate the resume against the provided job description. Match the provide JD summary, Resume Summary, the percentage match of Experience,Technical skills and Soft Skills of candidate with respective of JD. Find the aggregate percentage and reason behind the percentage based upon the data provid...",
        "ast": "FunctionDef(name='match_reason', args=arguments(posonlyargs=[], args=[arg(arg='jd_summary'), arg(arg='summarized_resume'), arg(arg='result'), arg(arg='stack')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='template', ctx=Store())], value=Constant(value='You are a skilled ATS (Applicant Tracking System) scanner with a deep understanding of {stack}, \\n    your task is to evaluate the resume against the provided job description. Match the provide JD summary, Resume Summary, the percentage match of Experience,Technical skills and Soft Skills of candidate with respective of JD.\\n    Find the aggregate percentage and reason behind the percentage based upon the data provided.\\n\\n    **Important:** \\n    - If a candidate has more experience than required, consider it as a full match for experience.\\n    \\n    Job Description Summary:\\n    {jd_summary}\\n    \\n\\n    Summarized Resume:\\n    {summarized_resume}\\n    \\n\\n    Result:\\n    {result}\\n    \\n\\n    \\n    Based upon the given data, give a reason for aggregate percentage only. Also mention what sort of profile candidate is more suitable for')), Assign(targets=[Name(id='llm', ctx=Store())], value=Call(func=Name(id='OpenAI', ctx=Load()), args=[], keywords=[keyword(arg='model_name', value=Constant(value='gpt-3.5-turbo-instruct')), keyword(arg='temperature', value=Constant(value=0))])), Assign(targets=[Name(id='prompt_input', ctx=Store())], value=Dict(keys=[Constant(value='stack'), Constant(value='jd_summary'), Constant(value='summarized_resume'), Constant(value='result')], values=[Name(id='stack', ctx=Load()), Name(id='jd_summary', ctx=Load()), Name(id='summarized_resume', ctx=Load()), Name(id='result', ctx=Load())])), Assign(targets=[Name(id='prompt', ctx=Store())], value=Call(func=Name(id='PromptTemplate', ctx=Load()), args=[], keywords=[keyword(arg='input_variables', value=List(elts=[Constant(value='stack'), Constant(value='jd_summary'), Constant(value='summarized_resume'), Constant(value='result')], ctx=Load())), keyword(arg='template', value=Name(id='template', ctx=Load()))])), Assign(targets=[Name(id='chain', ctx=Store())], value=Call(func=Name(id='LLMChain', ctx=Load()), args=[], keywords=[keyword(arg='llm', value=Name(id='llm', ctx=Load())), keyword(arg='prompt', value=Name(id='prompt', ctx=Load()))])), Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='invoke', ctx=Load()), args=[Name(id='prompt_input', ctx=Load())], keywords=[])), Return(value=Subscript(value=Name(id='output', ctx=Load()), slice=Constant(value='text'), ctx=Load()))], decorator_list=[])"
    },
    "aggregate_score": {
        "name": "aggregate_score",
        "docstring": "No docstring provided",
        "called_functions": [
            "float",
            "float",
            "float"
        ],
        "code": "def aggregate_score(json_data):\n    parsed_data = json.loads(json_data)\n    experience_match_percentage = float(parsed_data['Experience']['Match Percentage'][:-1])\n    technical_skills_match_percentage = float(parsed_data['Technical Skills']['Match Percentage'][:-1])\n    soft_skills_match_percentage = float(parsed_data['Soft Skills']['Match Percentage'][:-1])\n    aggregate_match_percentage = experience_match_percentage * 0.3 + technical_skills_match_percentage * 0.6 + soft_skills_match_percentage * 0.1\n    results = {'Experience Match Percentage': experience_match_percentage, 'Technical Skills Match Percentage': technical_skills_match_percentage, 'Soft Skills Match Percentage': soft_skills_match_percentage, 'Aggregate Match Percentage': aggregate_match_percentage}\n    return results",
        "summary": "Code: def aggregate_score(json_data): parsed_data = json.loads( json_data) experience_match_percentage = float(parsed_data['Experience'].'Match Percentage'], technical_skills_match-percentage: float (parsing_data.'Technical Skills'). 'Soft Skills': float('Soft Skills', 'Match Percentage', '0.3', '1', '2', '3',",
        "ast": "FunctionDef(name='aggregate_score', args=arguments(posonlyargs=[], args=[arg(arg='json_data')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parsed_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='json_data', ctx=Load())], keywords=[])), Assign(targets=[Name(id='experience_match_percentage', ctx=Store())], value=Call(func=Name(id='float', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Name(id='parsed_data', ctx=Load()), slice=Constant(value='Experience'), ctx=Load()), slice=Constant(value='Match Percentage'), ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='technical_skills_match_percentage', ctx=Store())], value=Call(func=Name(id='float', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Name(id='parsed_data', ctx=Load()), slice=Constant(value='Technical Skills'), ctx=Load()), slice=Constant(value='Match Percentage'), ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='soft_skills_match_percentage', ctx=Store())], value=Call(func=Name(id='float', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Name(id='parsed_data', ctx=Load()), slice=Constant(value='Soft Skills'), ctx=Load()), slice=Constant(value='Match Percentage'), ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aggregate_match_percentage', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Name(id='experience_match_percentage', ctx=Load()), op=Mult(), right=Constant(value=0.3)), op=Add(), right=BinOp(left=Name(id='technical_skills_match_percentage', ctx=Load()), op=Mult(), right=Constant(value=0.6))), op=Add(), right=BinOp(left=Name(id='soft_skills_match_percentage', ctx=Load()), op=Mult(), right=Constant(value=0.1)))), Assign(targets=[Name(id='results', ctx=Store())], value=Dict(keys=[Constant(value='Experience Match Percentage'), Constant(value='Technical Skills Match Percentage'), Constant(value='Soft Skills Match Percentage'), Constant(value='Aggregate Match Percentage')], values=[Name(id='experience_match_percentage', ctx=Load()), Name(id='technical_skills_match_percentage', ctx=Load()), Name(id='soft_skills_match_percentage', ctx=Load()), Name(id='aggregate_match_percentage', ctx=Load())])), Return(value=Name(id='results', ctx=Load()))], decorator_list=[])"
    },
    "main": {
        "name": "main",
        "docstring": "No docstring provided",
        "called_functions": [
            "process_jd",
            "process_resume",
            "remove_backticks_and_json",
            "summarize_jd",
            "summarize_resume",
            "match_profile",
            "aggregate_score",
            "match_reason",
            "jsonify",
            "jsonify",
            "jsonify",
            "jsonify"
        ],
        "code": "def main(jd_file_path: str, resume_file_path: str):\n    try:\n        job_description_json = process_jd(jd_file_path)\n        resume_json = process_resume(resume_file_path)\n        resume_json_cleared = remove_backticks_and_json(resume_json)\n        data1 = json.loads(job_description_json)\n        data2 = json.loads(resume_json_cleared)\n        job_description_summary = summarize_jd(jd_file_path)\n        resume_summary = summarize_resume(resume_file_path)\n        result = match_profile(data1, data2)\n        aggregate = aggregate_score(result)\n        reason_resut = match_reason(job_description_summary, resume_summary, aggregate, data1['job_title'])\n        return jsonify({'result': result, 'aggregate': aggregate, 'reason_result': reason_resut})\n    except json.decoder.JSONDecodeError as e:\n        return jsonify({'error': f'Error decoding JSON in file : {e}'})\n    except FileNotFoundError:\n        return jsonify({'error': 'File not found'})\n    except Exception as e:\n        return jsonify({'error': f'An unexpected error occurred: {e}'})",
        "summary": "The function is called main. It uses the process_jd function. No docstring is provided for the function. The function is named after the main file.",
        "ast": "FunctionDef(name='main', args=arguments(posonlyargs=[], args=[arg(arg='jd_file_path', annotation=Name(id='str', ctx=Load())), arg(arg='resume_file_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='job_description_json', ctx=Store())], value=Call(func=Name(id='process_jd', ctx=Load()), args=[Name(id='jd_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='resume_json', ctx=Store())], value=Call(func=Name(id='process_resume', ctx=Load()), args=[Name(id='resume_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='resume_json_cleared', ctx=Store())], value=Call(func=Name(id='remove_backticks_and_json', ctx=Load()), args=[Name(id='resume_json', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data1', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='job_description_json', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data2', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='resume_json_cleared', ctx=Load())], keywords=[])), Assign(targets=[Name(id='job_description_summary', ctx=Store())], value=Call(func=Name(id='summarize_jd', ctx=Load()), args=[Name(id='jd_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='resume_summary', ctx=Store())], value=Call(func=Name(id='summarize_resume', ctx=Load()), args=[Name(id='resume_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='match_profile', ctx=Load()), args=[Name(id='data1', ctx=Load()), Name(id='data2', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aggregate', ctx=Store())], value=Call(func=Name(id='aggregate_score', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='reason_resut', ctx=Store())], value=Call(func=Name(id='match_reason', ctx=Load()), args=[Name(id='job_description_summary', ctx=Load()), Name(id='resume_summary', ctx=Load()), Name(id='aggregate', ctx=Load()), Subscript(value=Name(id='data1', ctx=Load()), slice=Constant(value='job_title'), ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='jsonify', ctx=Load()), args=[Dict(keys=[Constant(value='result'), Constant(value='aggregate'), Constant(value='reason_result')], values=[Name(id='result', ctx=Load()), Name(id='aggregate', ctx=Load()), Name(id='reason_resut', ctx=Load())])], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='json', ctx=Load()), attr='decoder', ctx=Load()), attr='JSONDecodeError', ctx=Load()), name='e', body=[Return(value=Call(func=Name(id='jsonify', ctx=Load()), args=[Dict(keys=[Constant(value='error')], values=[JoinedStr(values=[Constant(value='Error decoding JSON in file : '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])])], keywords=[]))]), ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Call(func=Name(id='jsonify', ctx=Load()), args=[Dict(keys=[Constant(value='error')], values=[Constant(value='File not found')])], keywords=[]))]), ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=Call(func=Name(id='jsonify', ctx=Load()), args=[Dict(keys=[Constant(value='error')], values=[JoinedStr(values=[Constant(value='An unexpected error occurred: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])"
    },
    "process_files": {
        "name": "process_files",
        "docstring": "No docstring provided",
        "called_functions": [
            "main",
            "print",
            "jsonify"
        ],
        "code": "@app.route('/process', methods=['POST'])\ndef process_files():\n    if 'jd_file' not in request.files or 'resume_file' not in request.files:\n        print(request.files)\n        return jsonify({'error': 'Both JD and resume files are required.'})\n    jd_file = request.files['jd_file']\n    resume_file = request.files['resume_file']\n    jd_path = 'uploads/' + jd_file.filename\n    resume_path = 'uploads/' + resume_file.filename\n    jd_file.save(jd_path)\n    resume_file.save(resume_path)\n    return main(jd_path, resume_path)",
        "summary": "The function process_files is called when a request is made to the app. The function takes two files: a JD and a resume file. The code for the function is as follows:",
        "ast": "FunctionDef(name='process_files', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value='jd_file'), ops=[NotIn()], comparators=[Attribute(value=Name(id='request', ctx=Load()), attr='files', ctx=Load())]), Compare(left=Constant(value='resume_file'), ops=[NotIn()], comparators=[Attribute(value=Name(id='request', ctx=Load()), attr='files', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Attribute(value=Name(id='request', ctx=Load()), attr='files', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='jsonify', ctx=Load()), args=[Dict(keys=[Constant(value='error')], values=[Constant(value='Both JD and resume files are required.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='jd_file', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='request', ctx=Load()), attr='files', ctx=Load()), slice=Constant(value='jd_file'), ctx=Load())), Assign(targets=[Name(id='resume_file', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='request', ctx=Load()), attr='files', ctx=Load()), slice=Constant(value='resume_file'), ctx=Load())), Assign(targets=[Name(id='jd_path', ctx=Store())], value=BinOp(left=Constant(value='uploads/'), op=Add(), right=Attribute(value=Name(id='jd_file', ctx=Load()), attr='filename', ctx=Load()))), Assign(targets=[Name(id='resume_path', ctx=Store())], value=BinOp(left=Constant(value='uploads/'), op=Add(), right=Attribute(value=Name(id='resume_file', ctx=Load()), attr='filename', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='jd_file', ctx=Load()), attr='save', ctx=Load()), args=[Name(id='jd_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='resume_file', ctx=Load()), attr='save', ctx=Load()), args=[Name(id='resume_path', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='main', ctx=Load()), args=[Name(id='jd_path', ctx=Load()), Name(id='resume_path', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='app', ctx=Load()), attr='route', ctx=Load()), args=[Constant(value='/process')], keywords=[keyword(arg='methods', value=List(elts=[Constant(value='POST')], ctx=Load()))])])"
    }
}